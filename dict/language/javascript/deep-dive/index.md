---
title: 모던 자바스크립트 Deep Dive
---

[yes24](http://www.yes24.com/Product/Goods/92742567)
[교보](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791158392239)

## 1. 프로그래밍

### 3. 구문과 의미

```javascript
const number = 'string';
console.log(number * number);
```

문법적(syntax)으로 문제가 없지만 의미적(semantics)으로는 옳지 않다. 언어와 마찬가지로 코드는 문법에 맞는 문장을 구성하고 의미를 가져야한다. 

> 결국 프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것이다. 

## 2. 자바스크립트란?

### 3. 자바스크립트 성장의 역사

**Ajax**는 XMLHttpRequest라는 이름으로 등장, 서버와 브라우저가 비동기로 데이터를 교환할 수 있다. 기존에는 화면 전환시 전체를 렌더링하기에 깜빡거렸다. Ajax 이후에는 필요한 부분만 렌더링하는 방식이 가능해졌다. 

**jQuery**는 DOM을 쉽게 제어할 수 있게 했고 크로스 브라우징 이슈를 어느정도 해결했다. 

구글의 **V8 자바스크립트 엔진**으로 서버의 몇몇 로직이 클라이언트로 이동하여 프론트엔드가 주목받았다. 

**Node.js**는 자바스크립트를 브라우저 이외의 환경에서도 동작하게하며, 서버 개발에 주로 사용되며 이에 필요한 모듈, 파일 시스템, HTTP등 빌트인 API를 제공한다. 비동기 I/O를 지원하며 단일 스레드 이벤트 루프 기반으로 동작해 request 처리 성능이 좋다. 이에 I/O가 빈번한 SPA에 적합하며 CPU 사용률이 높은 부분에는 권장하지 않는다. 

이후 복잡해진 개발 과정에 대응하기 위해 패턴과 라이브러리가 출현했지만, 리액트와 같은 프레임워크가 등장했다. 

### 4. 자바스크립트와 ECMAScript

자바스크립트는 core인 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이즈 Web API(DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame...)등을 아우르는 개념이다. 

클라이언트사이즈는 ECMAScript와는 별개로 W3C에서 별도의 사양으로 관리하고 있다. 

### 5. 자바스크립트의 특징

웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다. 인터프리터 언어. 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어. 

## 3. 자바스크립트 개발 환경과 실행 방법

### 3. Node.js

> npm(node package manager)은 자바스크립트 패키지 매니저이다. Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공한다. 

## 4. 변수

변수에 저장된 값을 읽어들이는 것을 **참조**(reference)라 한다. 

변수 이름을 **식별자**(identifier)라고도 한다. 

### 3. 변수 선언

**변수 선언**(declaration)이란 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 것이다. 

ES6은 ES5의 superset이다. 

**키워드**란 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어다. 

자바스크립트 엔진은 변수 선언을 선언 단계와 초기화 단계 2단계에 걸쳐 수행한다. 

**실행 컨텍스트**는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다. 

**초기화**(initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다. 

### 4. 변수 선언의 실행 시점과 변수 호이스팅

자바스크립트에서 변수, 함수, 클래스등의 식별자는 호이스팅되어 런타임 단계에서 선언문들이(할당문 x) 먼저 실행된다.

!@chapter4/hoisting.js@!

### 5. 값의 할당

> 변수 선언은 런타임 이전에 먼저 실행되지만 값의 할당은 런타임에 실행된다. 

!@chapter4/hoisting2.js@!

### 6. 값의 재할당

변수에 값을 재할당하면 기존 공간을 지우고 그 메모리 공간에 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 값을 저장한다. 

**Unmanaged language / Managed language**는 저수준 메모리 제어 기능의 유무로 구분된다. 

### 7. 식별자 네이밍 규칙

특수문자를 제외한 문자, 숫자, 언더스코어, 달러 기호를 포함할 수 있으며, 숫자로 시작할 수 없으며, 예약어는 사용할 수 없다. 

!@chapter4/naming.js@!

## 5. 표현식과 문

### 1. 값

> 값(value)은 표현식(expression)이 평가(evaluation)되어 생성된 결과이다. 

> 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. 

### 2. 리터럴

> **리터럴**(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다. JS 엔진은 런타임에 리터럴을 평가해 값을 생성한다. 

!@chapter5/literal.js@!

### 3. 표현식

> **표현식**(expression)은 값으로 평가될 수 있는 문(statement)이다. 

> 식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식이다. 

리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메서드 호출 표현식...

문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다. 

### 4. 문

> **문**(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 

> **토큰**이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다. 

!@chapter5/statement.js@!

### 5. 세미콜론과 세미콜론 자동 삽입 기능

문을 끝낼 때에는 세미콜론을 붙여야 한다. 

코드 블록은 self closing의 성격을 가지기 때문에 세미콜론을 뒤에 붙이지 않아도 좋다. 

ASI(Automatic semicolon insertion)으로 인해 사실 세미콜론을 붙이지 않아도 되긴 한다. 

!@chapter5/asiFail.js@!

### 6. 표현식인 문과 표현식이 아닌 문

!@chapter5/statementExpression.js@!

## 6. 데이터 타입

**원시 타입**(primitive type): number, string, boolean, undefined, null, Symbol

**객체 타입**(object/reference type): 객체, 함수, 배열

!@chapter6/bigInt.js@!

### 1. 숫자 타입

!@chapter6/number.js@!
 
### 2. 문자열 타입

> 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합

일반적으로 작음따옴표를 사용. 

배열인 C와 객체인 Java와 다르게 JS에서 문자열은 원시 타입이며 immutable하다. 

### 3. 템플릿 리터럴

ES6부터 추가된 새로운 문자열 표기법. 백틱(`)을 사용하며 multiline string, expression interpolation, tagged template등의 기능을 제공한다. [참고](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals)

!@chapter6/escapeSequence.js@!

\n은 LF(Line Feed), \r은 CR(Carriage Return). 과거 타자기에서 전자는 종이를 한 줄 올리고 후자는 커서를 맨 앞줄로 이동시켰다. 요즘은 기능은 같지만 전자를 사용한다. 

!@chapter6/templateLiteral.js@!

> \+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 

### 5. undefined 타입

undefined 타입의 값은 undefined가 유일하다. 

> 자바스크립트 엔진이 변수를 초기화하는데 사용하는 undefined를 개발자가 의도적으로 변수에 할당한다면 undefined의 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장하지 않는다. ... 대신에 null을 사용

> 자바스크립트에서는 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 선언과 정의의 구분이 모호하다. ... ECMAScript 사양을 따라 변수는 선언하고 함수는 정의한다고 표현하자. 

### 6. null 타입

null타입의 값은 null이 유일하다. 변수 값의 의도적 부재(intentional absence)를 명시할 때 사용한다. 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다. 

### 9. 데이터 타입의 필요성

> 컴파일러 또는 인터프리터는 **심벌 테이블**이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다. 

> 자바스크립트에서의 변수는 선언이 아닌 할당에 의해 타입이 결정(type inference)된다. 그리고 재할당에 의해 변수의 타입은 바뀔 수 있다(dynamic typing). 

## 7. 연산자

> 피연산자가 '값'이라는 명사의 역할을 한다면 연산자는 '피연산자를 연산하여 새로운 값을 만들다'라는 동사의 역할을 한다고 볼 수 있다. 

### 1. 산술 연산자

**implicit coersion, type coercion**

!@chapter7/unaryPlus.js@!

!@chapter7/binaryPlus.js@!

### 2. 할당 연산자

!@chapter7/assignmentOperator.js@!

### 3. 비교 연산자

**동등 비교**(loose equality) 연산자는 암묵적 타입 변환을 통해 타입을 일치시킨 후 비교한다. 

!@chapter7/looseEquality.js@!

**일치 비교**(strict equality) 연산자는 타입또한 비교한다. 

!@chapter7/objectIs.js@!

### 6. 쉼표 연산자

> 왼쪽 피연산자부터 차례대로 평가하고 마지막 평가 결과를 반환한다.

!@chapter7/objectIs.js@!

### 7. typeof 연산자

!@chapter7/typeOf.js@!

### 11. 연산자의 부수 효과

> 부수 효과가 있는 연산자는 =, ++/--, delete 연산자다.

### 13. 연산자 결합 순서

> 연산자의 어느 쪽(좌항 또는 우항)부터 평가를 수행할 것인지

## 8. 제어문

> 고차함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다. 

### 1. 블록문

> 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다. 

### 2. 조건문

switch문에서 default문은 선택사항. if/else문은 논리적 참, 거짓으로 실행할 코드 블록을 결정하고, switch문은 다양한 상황(case)에 따라 결정한다. break문이 없으면 case문의 실행 흐름이 다음으로 넘어간다. 

!@chapter8/switchStatement.js@!

for문은 반복 횟수가 명확할 때 사용하고, while문은 불명확할 때 사용한다. 

### 4. break문

!@chapter8/labelStatement.js@!

## 9. 타입 변환과 단축 평가

명시적 타입 변환(explicit coercion) / 타입 캐스팅(type casting)

암묵적 타입 변환(implicit coercion) / 타입 강제 변환(type coercion)

위 두 타입 변환이 기존 원시 값을 변경하는 것은 아니다. 원시 값은 변경 불가능한 값(immutable value)이므로 변경할 수 없다. 

### 2. 암묵적 타입 변환

!@chapter9/implicitCoercion.js@!

### 3. 명시적 타입 변환

- 표준 빌트인 생성자 함수를 new 연산자 없이 호출
- 빌트인 메서드 사용
- 암묵적 타입 변환 이용

!@chapter9/explicitCoercion.js@!

### 4. 단축 평가

> 논리합 또는 논리곱 연산자는 전에나 2개의 피연산자 중 어느 한쪽으로 평가된다. 

!@chapter9/shortCircuitEvaluation.js@!

위 방법은 0이나 ''가 Falsy값이기 때문에 이를 그대로 반환하지만, 이들은 객체일 수 있기 때문에 아래의 옵셔널 체이닝 방법이 낫다. 

!@chapter9/optionalChaining.js@!

null 병합 연산자(nullish coalescing) 연산자도 바찬가지로 ||를 사용할 단축 평가로 대체할 수 있지만 Falsy값인 0과 ''도 유효한 기본값이라면 문제를 일으킬 수 있다. 

## 10. 객체 리터럴

### 1. 객체란?

원시 값을 제외한 나머지 값은 모두 객체다. 원시 값은 immutable value지만 객체는 mutable value이다. 

> 함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 한다. 자바스크립트에서 함수와 객체는 분리해서 생각할 수 없는 개념이다. 

### 2. 객체 리터럴에 의한 객체 생성

> 객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다는 데 주의하자. ... 따라서 객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다. 

### 3. 프로퍼티

프로퍼티 키에는 모든 문자열 또는 심벌 값이 사용될 수 있고, 프로퍼티 값으로는 모든 값이 가능하다. 

식별자 네이밍 규칙을 따르지 않는 키에는 반드시 따옴표를 사용해야 한다. 

!@chapter10/property.js@!

### 9. ES6에서 추가된 객체 리터럴의 확장 기능

!@chapter10/es6Property.js@!

## 11. 원시 값과 객체의 비교

- 원시값은 immutable, 객체는 mutable
- 원시값이 할당된 변수에는 실제 값이 저장되고, 객체가 할당된 변수에는 참조값이 저장된다. 
- 다른 변수에 할당시 원시 값은 복사되고(pass by value), 객체는 참조 값이 복사되어 전달된다(pass by reference).

### 1. 원시 값

한번 생성된 원시 값은 read only로 변경할 수 없다. 

원시 값을 할당한 변수에 다른 값을 재할당하면 새로운 메모리 공간을 확보하고 변수가 이곳을 가르키게 된다. 

> 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다. 

근데 immutable하다고 같은 메모리 주소에 머물러야한다는건 아니지 않나??? 재할당 안하고 그자리에서 바꾸는건 왜 안됨? 어차피 복사라서 상태 변경을 걱정할 필요는 없지 않나. 

그림에서는 메모리 주소로 표현했는데 실제로는 레지스터고 암튼 설명용일 수 있으니 일단 넘어가자. 

암튼 변수가 원시 값을 가리키는 한 변수를 재할당하지 않는 이상 그 변수 값이 유지될 것임이 보장된다. 

문자열도 원시값이므로 변경할 수 없다. 

!@chapter11/immutableString.js@!

> 참고로 '값에 의한 전달'이라는 용어는 자바스크립트를 위한 용어가 아니므로 사실 오해가 있을 수도 있다. **엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문이다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

### 2. 객체

객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다. 

> 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블(연관 배열, map, dictionary, looup table)이라고 생각할 수 있다. 

클래스 기반 언어는 프로퍼티/메서드가 정해져 있지만 자바스크립트는 동적으로 변할 수 있으므로 비효율적이다. 이에 V8 엔진에서는 동적 탐색(dynamic lookup) 대신 히든 클래스(hidden class)라는 방식을 사용해 성능을 높인다. (147p 참고)

객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값(reference value)에 접근할 수 있다. 참조값이 객체가 저장된 메모리 공간의 주소이다. 

왜 한번에 객체로 안가게 했지??

[Understanding JavaScript Pass-By-Value](https://www.javascripttutorial.net/javascript-pass-by-value/)
[Does javascript pass by reference?](https://stackoverflow.com/a/13104528)
[Evaluation strategy](https://en.wikipedia.org/wiki/Evaluation_strategy)

나중에 한번 더 정리해보면 좋을 듯. 

## 12. 함수

### 1. 함수란?

> 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

매개변수(parameter), 인수(argument), 반환값(return value) 

### 3. 함수 리터럴

함수 리터럴에서 함수 이름은 생략 가능하며, 만약 있다면 함수 몸체 내에서만 참조할 수 있는 식별자이다. 

함수는 객체이며 일반 객체와 다르게 호출할 수 있다. 

### 4. 함수 정의

**함수 선언문**

함수 선언문은 표현식이 아닌 문이다. 다만 함수 이름이 있는 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다. 

!@chapter12/functionLiteral.js@!

> 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다. 

> 자바스크립트의 함수는 일급 객체다. 

!@chapter12/functionHoisting.js@!

> 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다. 

!@chapter12/functionConstructorFunction.js@!

### 5. 함수 호출

매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다. 

!@chapter12/argumentProperty.js@!

> 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다. 

> 객체의 상태 변경을 원천봉쇄하고 객체의 상태 변경이 필요한 경우에는 객체의 방어적 복사(defensive copy)를 통해 원본 객체를 완전히 복제, 즉 깊은 복사(deep copy)를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다. 

### 7. 다양한 함수의 형태

즉시 실행 함수(IFE, Immediately Invoked Function Expression)

> 일반적으로 중첩 함수는 외부 함수를 돕는 헬퍼 함수(helper function) 역할을 한다. 

> 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수(callback function)라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수(higher-order function, HOF)라고 한다. 

> 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성 immutability 을 지향하는 프로그래밍 패러다임이다. 로직 내에 존재하는 조건문과 반복문을 제거해서 복잡 성을 해결하며, 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다. 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 해서 가독성을 해치고, 변수의 값은 누군 가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있기 때문이다.

## 13. 스코프

### 1. 스코프란?

> 스코프는 식별자가 유효한 범위, 혹은 식별자를 검색할 때 사용하는 규칙을 말한다. 

191p. 하나의 값은 유일한 식별자에 연결되어야 한다? pass by reference는 예외인건가? 여기서 값은 객체 타입은 제외한건가. 

var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. 

### 2. 스코프의 종류

> 지역이란 함수 몸체 내부를 말한다. 

### 3. 스코프 체인

함수 몸체 내부에서 정의한 함수를 **중첩 함수(nested function)**, 중첩 함수를 포함하는 함수를 **외부 함수(outer function)**라고 한다. 

스코프가 계층적으로 연결된 것을 **스코프 체인(scope chain)**이라 한다. 

자바스크립트 엔진은 상위 스코프 방향으로 이동하며 선언된 변수를 검색(identifier resolution)한다. 

> 사실 함수는 식별자에 함수 객체가 할당된 것 외에는 일반 변수와 다를 바 없다. 따라서 스코프를 ‘변수를 검색할 때 사용하는 규칙’이라고 표현하기보다는 ‘식별자를 검색하는 규칙’이라고 표현하는 편이 좀 더 적합하다. 

### 4. 함수 레벨 스코프

코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다. 

블록 레벨 스코프(C, Java …) / 함수 레벨 스코프(JS var)


### 5. 렉시컬 스코프

!@chapter13/lexicalScope.js@!

- 동적 스코프(dnamic scope): 함수가 호출되는 시점에 동적으로 상위 스코프를 결정한다. 
- 렉시컬 스코프(lexical scope/static scope): 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다. 

자바스크립트와 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다. 

함수 정의가 실행되어 생성된 함수 객체는 결정된 상위 스코프를 기억한다. 렉시컬 스코프는 클로저와 깊은 관계가 있다. 

## 14. 전역 변수의 문제점

### 1. 변수의 생명 주기

변수는 생명 주기(life cycle)가 있다. 

전역 변수의 생명 주기는 응용 프로그램의 생명 주기와 같다. 지역 변수의 생명 주기는 함수의 생명 주기와 같다. 

!@chapter13/varLifeCycle.js@!

전역변수는 호이스팅으로 인해 런타임 이전 단계에 선언문이 실행되지만, 함수 내부의 변수는 함수가 호출된 직후와 함수 몸체의 코드가 실행되기 이전 자바스크립트 엔진에 의해 선언문이 실행된다. 호이스팅은 스코프를 단위로 동작한다. 

변수는 자신이 등록된 스코프가 소멸(메모리 해제)될 때까지 유효하다. ... **누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.**

### 2. 전역 변수의 문제점

전역 변수는 스코프 체인의 종점의 존재하여 미미하지만 검색 속도가 가장 느리다. 

자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다는 것인데, 다른 파일에 같은 이름으로 명명된 전역 변수가 있다면 예상치 못한 결과가 발생할 수 있다. 

### 3. 전역 변수의 사용을 억제하는 방법

즉시 실행 함수, 네임스페이스 객체, 모듈 패턴

모듈 패턴은 클로저를 기반으로 동작하며, 전역 네임스페이스의 오염을 막는 동시에 정보 은닉을 구현하기 위해 사용된다. 

!@chapter13/modulePattern.js@!

ES6 모듈을 파일 자체의 독자적인 모듈 스코프를 제공한다. 

## 15. let, const 키워드와 블록 레벨 스코프

### 1. var 키워드로 선언한 변수의 문제점

var는 변수 중복 선언 허용, 함수 레벨 스코프, 변수 호이스팅이 발생한다는 단점을 지닌다. 

### 2. let 키워드

let 키워드로 선언한 변수는 선언 단계가 런타임 이전에 실행되지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다. 

스코프의 시작 지점부터 초기화 단계 시작 지점까지의 구간을 일시적 사각지대(Temporal Dead Zone; TDZ)라고 부른다. 

!@chapter15/letHoisting.js@!

let도 변수 호이스팅이 발생하기에 전역 변수에 접근하지는 않는다. 자바스크립트는 모든 선언을 호이스팅한다. 

!@chapter15/globalObject.js@!

let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 

### 3. const 키워드

반드시 선언과 동시에 초기화해야 한다. 

보통 대문자와 언더스코어를 사용해 표현한다. 

const 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않는다. 

> Angular, React, Vue.js와 같은 SPA 프레임워크에서는 상태가 변경되었음을 명확히 하기 위해 변경된 객체를 재할당하는 경우도 있다. 

## 16. 프로퍼티 어트리뷰트

### 1. 내부 슬롯과 내부 메서드

internal slot/method

자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 psudo property/method. 이름이 이중 대괄호로 감싸져있다. 

엔진 내부 로직이므로 원칙적으로 접근이 불가하지만, 일부에 한해 접근 수단을 제공하기는 한다. 

!@chapter16/internalSlot.js@!

### 2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 **프로퍼티 어트리뷰트**를 기본값으로 자동 정의한다. 

!@chapter16/propertyAttribute.js@!

### 3. 데이터 프로퍼티와 접근자 프로퍼티

프로퍼티는 두가지로 구분할 수 있다. 

- data property: 키와 값으로 구성된 일반적인 프로퍼티
- accessor property: 자체 값이 없고 접근자 함수(accessor function)으로 구성된 프로퍼티

!@chapter16/dataProperty.js@!

[[Value]]: 프로퍼티 값
[[Writable]]: 값 변경 가능 여부
[[Enumerable]]: 열거 가능 여부
[[Configurable]]: false이면 프로퍼티 삭제 및 어트리뷰트 값 변경 불가, 단 [[Writable]]이 true면 value의 변경과 [[Writable]]을 false로 변경하는 것이 가능. 

아래 세개의 기본값은 true이다. 

접근자 프로퍼티는 [[Get]], [[Set]], [[Enumerable]], [[Configurable]]을 가지며 getter/setter는 둘 중 하나만 가질 수도 있다. 

!@chapter16/accessorProperty.js@!

### 4. 프로퍼티 정의

!@chapter16/defineProperty.js@!

### 5. 객체 변경 방지

프로퍼티 추가, 삭제, 읽기, 쓰기, 어트리뷰트 재정의 중
Object.preventExtensions는 추가 외 허용, 
.seal은 읽기 쓰기 외 비허용, 
.freeze는 읽기만 허용한다. 

이들은 얕은 변경 방지(shallow only)로 직속 프로퍼티만 변경이 방지된다. 

## 17. 생성자 함수에 의한 객체 생성

### 1. Object 생성자 함수

> 생성자 함수(constructor)란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다.

> 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라고 한다. 

!@chapter17/constructor.js@!

### 2. 생성자 함수

생성자 함수를 사용하면 객체 리터럴을 사용한 방법과 달리 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 

!@chapter17/constructorGood.js@!

new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다. 

!@chapter17/constructorWithoutNew.js@!

인스턴스 생성, this에 이를 바인딩 -> 생성자 함수 내의 코드로 인스턴스 초기화 -> this 암묵적 반환

함수는 객체이지만 일반 객체와 다르게 호출할 수 있다. 

함수가 일반 함수로 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고, 생성자 함수로 호출되면 [[Construct]]가 호출된다. 

- constructor: 함수 선언문/표현식, 클래스
- non-constructor: ES6 메서드 축약 표현, 화살표 함수

!@chapter17/es6Method.js@!

생성자 함수는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력한다. 그럼에도 실수의 위험성을 회피하기 위해 ES6에서는 new.target을 지원한다. 

!@chapter17/newTarget.js@!

대부분의 빌트인 생성자 함수는 new 연산자 유무에 상관없이 적절한 값을 반환하지만, String, Number, Boolean은 new가 있으면 객체, 없으면 값을 반환한다. 

## 18. 함수와 일급 객체

### 1. 일급 객체

- 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다. 
- 변수나 자료구조(객체, 배열 등)에 저장할 수 있다. 
- 함수의 매개변수에 전달할 수 있다. 
- 함수의 반환값으로 사용할 수 있다. 

[Why are functions not considered first class citizens in c?](https://stackoverflow.com/questions/48092176/why-are-functions-not-considered-first-class-citizens-in-c?answertab=trending#tab-top)

### 2. 함수 객체의 프로퍼티

!@chapter18/functionProperty.js@!

__proto__ 프로퍼티는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다. 

prototype 프로퍼티는 constructor만 소유하는 프로퍼티이다. 생성자 함수로 함수가 호출될 때 생성되는 인스턴스의 프로토타입 객체를 가리킨다. 

## 19. 프로토타입

### 1. 객체지향 프로그래밍

> 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 객체라 한다. 

> 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다. 

### 2. 상속과 프로토타입

!@chapter19/methodShare.js@!

Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 상속받는다. 

### 3. 프로토타입 객체

모든 객체는 하나의 프로토타입을 갖고, 모든 프로토타입은 생성자 함수와 연결되어 있다. 

!@chapter19/prototypeLink.js@!

__proto__ 접근자 프로퍼티는 객체가 직접 소유하지 않고 Object.prototype의 프로퍼티를 상속을 통해 사용된다. 

!@chapter19/cyclicProto.js@!

__proto__ 대신 getPrototypeOf와 setPrototypeOf가 권장된다. 왜??

### 4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.  

프로토타입의 constructor 프로퍼티를 통해 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 크게 무리는 없다. 

이 부분은 추후 다시 읽어보기.

> 추상 연산(abstract operation)은 ECMAScript 사양에서 내부 동작의 구현 알고리즘을 표현한 것이다.

### 5. 프로토타입의 생성 시점

프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 

함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되며, 이때 프로토타입도 더불어 생성된다. 이 프로토타입의 프로토타입은 언제나 Object.prototype이다. 

모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 

### 6. 객체 생성 방식과 프로토타입의 결정

객체는 어떤 방식으로 생성되든지 OrdinaryObjectCreate 추상 연산에 의해 생성된다는 공통점이 있다. 이 추상 연산에 결정되는 인수에 따라 생성되는 객체의 프로토타입이 결정된다. 

!@chapter19/constructorPrototypeQ.js@!

### 7. 프로토타입 체인

> 자바스크립트는 해당 객체에 찾고자하는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라 하며, 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘이다. 

모든 객체는 Object.prototype을 상속받으며 이는 프로토타입 체인의 종점이다. 

프로토타입 체인은 상속과 프로퍼티 검색을 위한, 스코프 체인은 식별자 검색을 위한 매커니즘이다. 

### 8. 오버라이딩과 프로퍼티 섀도잉

> 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉이라 한다. 

> 오버라이딩이란 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식이다. 

하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다. 

### 9. 프로토타입의 교체

객체 간의 상속 관계를 동적으로 변경할 수 있다. 

프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다. 

프로토타입은 직접 교체하지 않는 것이 좋다. 

상속 관계를 인위적으로 설정하려면 번거로운 프로토타입 교체보다 직접 상속이나 클래스를 사용하는 편이 좋다. 

### 10. instanceof 연산자

좌변에 객체, 우변에 생성자 함수

생성자 함수의 prototype 프로퍼티가 객체의 프로토타입 체인에 존재하는지 확인한다. 

instanceof 연산자는 constructor 프로퍼티가 아닌 생성자 함수의 prototype에 바인딩된 객체가 체인에 존재하는지 확인한다. 

!@chapter19/instanceof.js@!

### 11. 직접 상속

new 연산자가 필요 없고, 프로토타입을 지정하며 객체를 생성할 수 있으며, 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다. 

프로토타입 체인의 종점에 위치한 객체를 생성할 수 있으므로, Object.prototype의 빌트인 메서드를 직접 호출하는 것은 권장하지 않는다. call 등의 메서드로 간접 호출을 권함. 

!@chapter19/directInheritance.js@!

ES6에서는 객체 리터럴 내부에서 __proto__ 접근자 프로퍼티를 사용해 직접 상속을 구현할 수 있다. 

```js
obj = {
    name: 'YeolYi',
    __proto__: myProto
};
```

### 12. 정적 프로퍼티/메서드

> 생성자 함수 객체가 소유한 프로퍼티/메서드를 정적 프로퍼티/메서드라고 한다. 

prototype을 #으로 표기하는 경우도 있으니 알아두자. Object#isPrototypeOf.

### 13. 프로퍼티 존재 확인

!@chapter19/propertyExistence.js@!

### 14. 프로퍼티 열거

!@chapter19/propertyEnumerate.js@!

## 20. strict mode

린트 도구는 strict mode가 제한하는 오류는 물론 코딩 컨벤션을 설정 파일 형태로 저으이하고 강제할 수 있기 때문에 더욱 강력한 효과를 얻을 수 있다. 

전역과 함수단위로 strict mode를 적용하는 것은 피하고, 즉시 실행함수로 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다. 

암묵적 전역, 변수/함수/매개변수의 삭제, 매개변수의 중복, with문의 사용에 대해 에러가 발생한다. 

[with 명령에 대하여](https://unikys.tistory.com/304)

일반함수에서 this에 undefined가 바인딩되며, 매개변수에 전달된 인수를 재할당해도 arguments 객체에 반영되지 않는다. 

!@chapter20/argumentBinding.js@!

## 21. 빌트인 객체

### 1. 자바스크립트 객체의 분류

ECMAScript 사양에 정의된 표준 빌트인 객체(standard built-in objects, natice objects, global objects), 자바스크립트 실행 환경에 따라 추가로 제공하는 호스트 객체, 사용자 정의 객체가 있다. 

### 2. 표준 빌트인 객체

Math, Reflect, JSON을 제외하고 모두 생성자 함수 객체이다. 

### 3. 원시값과 래퍼 객체

> 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라 한다. 

래퍼 객체의 처리가 종료되면 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다. 

!@chapter21/wrapperObject.js@!

### 4. 전역 객체

> 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체이다.

표준 빌트인 객체, 호스트 객체, 전역 변수/함수를 프로퍼티로 가진다. 

let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 

브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다. 

Infinity, NaN, undefined는 빌트인 전역 프로퍼티다. 

!@chapter21/builtinGlobalFunction.js@!

> URI(Uniform Resource Identifier)는 인터넷에 있는 자원을 나타내는 유일한 주소로, 하위개념으로 URL, URN이 있다. 

인코딩이한 URI의 문자들을 이스케이프 처리(아스키 문자 셋으로 변환)하는 것이다. 

!@chapter21/uri.js@!

암묵적 전역 현상에서는 변수가 아닌 프로퍼티가 생성되고, 따라서 변수 호이스팅이 발생하지 않고 delete 연산자로 삭제할 수 있다. 

## 22. this

### 1. this 키워드

> this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)이다. 

this는 일반함수에서 전역 객체, 메서드에서 메서드를 호출한 객체, 생성자 함수 내부에서는 생성될 인스턴스를 가리킨다. 

### 2. 함수 호출 방식과 this 바인딩

렉시컬 스코프는 평가 시점, this 바인딩은 호출 시점에 결정된다. 동일한 함수도 다양하게 호출하여 다른 this가 바인딩될 수 있다. 

어떠한 함수(중첩 함수, 콜백 함수..)라도 일반 함수로 호출되면 this 객체에 전역 객체가 바인딩된다. 

이는 중첩 함수가 헬퍼함수로서 동작하기 힘들게하므로 this 바인딩을 특정 변수에 할당하여 헬퍼 함수에서 사용하거나, apply/call/binding 메서드를 사용하거나, 화살표 함수를 사용할 수 있다. 

메서드 내의 this도 호출한 함수에 따라 달라진다. 

!@chapter22/methodThis.js@!

apply/call/binding 메서드는 Function.prototype의 메서드다. 

!@chapter22/applyCallBinding.js@!

## 23. 실행 컨텍스트

### 1. 소스코드의 타입

각 타입은 실행 컨텍스트를 생성한다. 타입에 따라 실행 컨텍스트의 생성 과정과 관리 내용이 다르다.

전역 코드: 최상위 스코프인 전역 스코프 생성. var, 전역에 선언된 함수 선언문
함수 코드: 지역 스코프 생성, 스코프 체인에 연결. 지역변수, 매개변수, argument 객체
모듈 코드: 모듈별로 독립적인 모듈 스코프

### 2. 소스코드의 평가와 실행

소스코드 평가 과정에서 컨텍스트를 생성하고 선언문들을 실행하여 식별자를 실행 컨텍스트가 관리하는 스코프에 등록한다. 

이후 실행, 런타임이 시작되어 필요한 값을 스코프에서 얻어오고 실행 결과를 스코프에 등록하는 과정.

### 3. 실행 컨텍스트의 역할

전역 코드 평가 -> 전역 코드 평가 -> 함수 코드 평가 -> 함수 코드 실행

코드가 실행되려면 스코프, 식별자, 코드 실행 순서의 관리가 필요하다. 

1. 선언에 의해 생성된 식별자를 스코프를 구분해 등록하고 상태 변화를 관리해야한다. 
2. 스코프는 중첩 관계에 의한 스코프 체인을 형성해야한다. 
3. 현재 실행중인 코드의 실행 순서를 변경할 수 있어야 한다?

> 실행 컨텍스트는 소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 

이거는 JS가 인터프리터 언어이기 때문인가? 컴파일하는 언어는 이 작업을 컴파일 중에 하는건가?

렉시컬 환경과 실행 컨텍스트 스택으로 구성?된다. 

### 4. 실행 컨텍스트 스택

혹은 콜 스택. 코드 실행 순서를 관리한다.

전역 코드가 평가되고, 함수 코드가 평가되면 실행 컨텍스트가 생기는데 이들을 스택 형태로 관리한다. C에서의 스택/힙에서 스택과 유사한듯.

최상단의 컨텍스트를 실행 중인 실행 컨텍스트(running execution context)라 한다. 

### 5. 렉시컬 환경

Lexical environment. 식별자와 그에 바인딩 된 값(환경 레코드, environment record), 상위 스코프에 대한 참조(외부 렉시컬 환경에 대한 참조, outer lexical environment reference)를 기록하는 자료구조. 렉시컬 스코프의 실체. LexicalEnvironment와 VariableEnvironment로 구성되지만 대부분 비슷하다. 

환경 레코드는 소스코드의 타입에 따라 관리하는 내용에 차이가 있다. 외부 렉시컬 어쩌구를 통해 스코프 체인을 구현한다. 

### 6. 실행 컨텍스트의 생성과 식별자 검색 과정

**전역 객체 생성**
- 전역 코드 평가 이전에 생성
- 전역 객체도 Object.prototype을 상속받는다. 

**전역 코드 평가**
- 전역 실행 컨텍스트 생성, 스택에 push
- 전역 렉시컬 환경 생성, 위의 컨텍스트에 바인딩
- 전역 환경 레코드 생성. var 및 나머지는 객체 환경 레코드(Object Environment Record), let/const는 선언적 환경 레코드(Declarative Environment Record)에서 관리. 
- 객체 환경 레코드 생성. 객체 환경 레코드는 BindingObject라는 객체와 연결, 이는 전역 객체 생성에서 생성된 전역 객체. var와 전역 변수, 함수 선언문은 BindingObject를 통해 연결된 전역 객체의 프로퍼티와 메서드가 된다. 
- 선언적 환경 레코드 생성. 이곳의 변수들은 일시적 사각지대(Temporal Dead Zone, TDZ)에 빠진다. 
- this 바인딩. 전역 환경 레코드의 [[GlobalThisValue]]에 this(보통 전역객체)가 바인딩된다. 
- 외부 렉시컬 환경에 대한 참조 결정: 전역이므로 전역 렉시컬 환경의 OuterLexicalEnvironmentReference에 null이 할당. 

let은 블록 레벨 스코프인데, 블록에 들어가면 새로운 컨텍스트가 생기는건가?
-> 챕터 7 참조

**전역 코드 실행**
pass

**함수 코드 평가**
- 힘수 실행 컨텍스트 생성: 스택에 push
- 함수 렉시컬 환경 생성
    - 함수 환경 레코드 생성: 매개변수, arguments 객체, 지역 변수, 중첩 함수 등록 및 관리
    - this 바인딩: 함수 호출 방식에 따라 this 결정. 
    - 외부 렉시컬 환경에 대한 참조 결정: 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 [[Environment]]에 할당한다. 이는 클로저와 연관된다. 

**함수 코드 실행**
이후 실행이 완료된 함수의 컨텍스트를 pop. 다만 컨텍스트가 소멸되었더라도 그에 바인딩된 렉시컬 환경을 누군가 참조한다면 이는 소멸하지 않는다. 

### 7. 실행 컨텍스트와 블록 레벨 스코프

코드 블록에 들어가면 새로운 선언적 환경 레코드를 가진 렉시컬 환경을 만들어 기존 것을 대체. 대신 새로운 환경 내 외부 렉시컬 환경에 대한 참조는 기존 것을 가리킨다. 

변수 선언문에 let을 사용한 for문은 코드 블록이 실행될 때마다 새로운 렉시컬 환경을 생성한다?? 이에 대해서는 클로저에서 자세히...

## 24. 클로저

> A closure is the combination of a function and the lexical environment within which that function was declared.

### 1. 렉시컬 스코프

> 렉시컬 환경의 '외부 렉시컬 환경에 대한 참조'에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 사용 시점이 아닌 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬 스코프다. 

### 2. 함수 객체의 내부 슬롯 [[Environment]]

함수가 호출되었을 때 생성될 '외부 렉시컬 환경에 대한 참조'에 저장될 참조값과 같다. 함수는 여기에 저장되는 상위 스코프를 자신이 존재하는 한 기억한다. 

!@chapter24/environment.js@!

### 3. 클로저와 렉시컬 환경

> 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저(closure)라고 부른다. 

자바스크립트의 모든 함수가 상위 스코프를 기억하므로 이론적으로는 모든 함수가 클로저이지만, 상위 스코프의 어떠한 식별자도 참조하지 않는 경우 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않기 때문에 클로저라고 부르기 어렵다. 일부만 참조하는 경우에도 다른 식별자는 기억하지 않는다. 

또한 상위 함수보다 수명이 짧아도 클로저라 부르기 어렵다. 

debugger 구문 입력하고 브라우저에서 실행하면 스코프 정보를 볼 수 있다. 

> 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수(free variable)라고 부른다. 

### 4. 클로저의 활용

상태를 은닉하고 특성 함수에게만 변경을 허용하기 위해 사용한다. 

!@chapter24/informationHiding.js@!

한 함수에서 여러 스코프에 접근한다면 [[Environment]]의 참조는?

함수를 호출할 때마다 새로운 렉시컬 환경이 생김을 기억하자. 

### 5. 캡슐화와 정보 은닉

자바스크립트는 접근 제한자를 제공하지 않는다. [최신 버전에는 있기는 한듯?](https://stackoverflow.com/questions/38243329/classes-access-modifiers-in-javascript) 
-> private 필드에 대해서는 25.7.4에서.


[이런](https://medium.com/@weberino/you-can-create-truly-private-properties-in-js-without-es6-7d770f55fbc3) 방법도 있다. 

### 6. 자주 발생하는 실수

!chapter24/@commonMistake.js@!

## 25. 클래스

### 1. 클래스는 프로토타입의 문법적 설탕인가?

클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다. 

- 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 
- 클래스는 extends와 super 키워드를 제공한다. 
- 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 
- 클래스 내의 모든 코드에는 strict mode가 암묵적으로 적용된다.
- 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 [[Enumerable]]이 false이다. 

클래스는 새로운 객체 생성 매커니즘이다. 

### 2. 클래스 정의

클래스는 함수며 일급 객체이다. 

### 3. 클래스 호이스팅

클래스 선언문으로 정의한 클래스는 런타임 이전에 평가되지만 클래스 정의 이전에 참조할 수 없다. 

!@chapter25/classHoisting.js@!

### 5. 메서드

constructor는 메서드로 해석되지 않고 클래스가 평가되어 생성된 함수 객체 코드의 일부가 된다. 이에 클래스가 평가된 함수 객체를 봐도 constructor 메서드가 따로 있지 않다. 

constructor는 0개 혹은 1개 존재해야한다. constructor 내에서는 인스턴스의 생성과 프로퍼티 추가를 통한 인스턴스 초기화를 실행한다. 

메서드에 static 키워드를 붙이면 정적 메서드가 된다. 

프로토타입 메서드에서 this는 인스턴스, 정적 메서드의 this는 클래스를 가리킨다. 

정적 메서드는 애플리케이션 전역에서 사용할 유틸리티 함수를 전역 함수로 정의하지 않고 메서드로 구조화할 때 유용하다. 

- function 키워드를 생략한 축약 표현
- 콤마 필요 없음
- 암묵적 strict mode
- 열거 불가
- non-constructor

### 6. 클래스의 인스턴스 생성 과정

constructor 에서의 this는 내부 코드가 실행될 시점에 이미 클래스의 prototype 프로퍼티가 가리키는 객체가 프로토타입으로 설정되어있다. 

### 7. 프로퍼티

!@chapter25/getOwnPropertyName.js@!

인스턴스 프로퍼티를 자바처럼 정의할 수 있는 Class field declarations가 최신 브라우저에 구현되어 있다. 메소드도 이를 통해 정의할 수 있지만 프로토타입 메서드가 아닌 인스턴스 메서드가 되므로 권장하지 않는다. 

[선언, 정의, 초기화](https://salkuma.wordpress.com/2014/02/05/선언-정의-초기화-기본생성자-그리고-시그너처/)

!@chapter25/accessModifier.js@!

static을 사용한 정적 필드도 최신 브라우저에 구현되어 있다. 

### 8. 상속에 의한 클래스 확장

프로토타입 기반은 다른 객체의 자산을 상속받는 개념이지만 상속에 의한 클래스 확장은 새로운 클래스를 확장하여 정의하는 것이다. 

인스턴스끼리뿐만 아니라 수퍼클래스와 서브클래스는 둘 간 프로토타입 체인도 생성한다. 

동적 상속이 가능하다. 

서브클래스에 constructor를 생략하면 다음과 같은 constructor가 암묵적으로 정의된다. 

```javascript
constructor(...args) { super(...args); }
```

super를 호출하면 수퍼클래스의 constructor를 호출한다.

- 서브클래스에서 constructor를 생략하지 않았다면 그 constructor에서는 super를 반드시 호출해야한다. 
- super 호출 전에는 this를 참조할 수 없다. this를 super에서 만들기 때문이다. 
- super는 서브클래스의 constructor 내부에서만 호출할 수 있다. 

super를 참조해 수퍼클래스의 메서드를 호출할 수 있다. super는 자신을 참조하는 메서드가 바인딩된 객체의 프로토타입을 가리킨다. 

!@chapter25/superMethod.js@!

super를 위해 메서드는 내부 슬롯 [[HomeObject]]를 가지며 의사 코드는 다음과 같다. 이 슬롯은 ES6 메서드 축약 표현으로 정의된 함수만 지닌다. 이 슬롯을 가져야 super를 참조할 수 있다. 

[[HomeObject]]는 메서드가 바인딩 된 객체를 가리킨다. 

```javascript
super = Object.getPrototypeOf([[HomeObject]])
```

[[ConstructorKind]]의 base/derived 구분을 통해 new 연산자로 호출되었을 때 동작을 구분한다. 서브클래스는 수퍼클래스에게 인스턴스 생성을 위임한다. 이때 수퍼클래스의 constructor의 this의 프로토타입은 서브클래스의 prototype 프로퍼티이다. 

!@chapter25/mySpecies.js@!

## 26. ES6 함수의 추가 기능

### 1. 함수의 구분

객체에 바인딩된 함수(콜백 함수도 마찬가지)가 생성자 함수로 호출할 수 있다는 것은 해당 함수가 prototype 프로퍼티를 가지며 프로토타입 객체도 생성한다는 것이므로 성능상의 문제또한 있다. 

ES6 이전의 함수는 명확한 구분이 없었는데, ES6에서부터 함수를 사용 목적에 따라 분류한다. 

- Normal: constructor/prototype/arguments
- Method: super/arguments
- Arrow: -

세 가지 이외에도 제너레이터 함수와 async 함수가 있으며 46장에서 살펴본다. 

### 2. 메서드

> ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다. 

[[HomeObject]]를 가지기에 super 키워드를 사용할 수 있다. 

### 3. 화살표 함수

화살표 함수는 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용하다. 

객체 리터럴을 반환하는 경우 리터럴을 소괄호로 감싸주어야한다. 아니면 객체 리터럴의 중괄호가 함수 몸체를 감싸는 중괄호로 잘못 해석된다. 

화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않으며 스코프 체인 상에서 가장 가까운 상위 함수 중 화살표 함수가 아닌 함수의 것들을 참조한다. 

> 화살표 함수는 자체의 this가 없기에 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라 한다. 

ES6이전에는 this를 스코프 체인을 따라 탐색할 이유가 없었지만, 화살표 함수 이후 탐색이 필요해졌다. 

!@chapter26/lexicalThis.js@!

이처럼 메서드(ES6이 아닌 일반적인 의미)를 화살표 함수로 정의하는 것은 피해야 한다. 

스코프에 대해서는 다시 공부해봐야할 듯^^; class도 결국엔 함수라는 것을 체화시켜야 할 듯. 486페이지 다시 읽어보기. [실행 컨텍스트와 자바스크립트의 동작 원리](https://poiemaweb.com/js-execution-context)

### 4. Rest 파라미터

화살표 함수는 자신의 argument 객체를 가지지 않고, 접근한다해도 자신과 상관없는 상위 함수에 전달된 인수 목록을 알게 되므로 쓸모가 없다. 화살표 함수로 가변 인자 함수를 구현하기 위해서는 반드시 Rest 파라미터를 사용해야 한다. 

> Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다. 

함수의 length 프로퍼티에 영향을 주지 않는다. 

유사 배열 객체인 arguments를 사용하는 번거로움을 피할 수 있다. 

## 27. 배열

### 1. 배열이란?

!@chapter27/arrayBasic.js@!

배열은 일반 객체와 달리 값의 순서가 존재한다. 

### 2. 자바스크립트 배열은 배열이 아니다. 

> 자료구조에서 말하는 배열, 즉 밀집 배열(dense array)은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조이다. 

> 자바스크립트의 배열은 배열의 구조가 연속적으로 이어져있지 않은 희소 배열(sparse array)이다.?

자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다. 해시 테이블로 구현되어 인덱스 접근은 느리지만 요소의 삽입과 삭제는 빠르다. 

!@chapter27/arrayPerformance.js@!

### 3. length 프로퍼티와 희소 배열

length 프로퍼티에 그 값보다 작은 값을 할당하면 배열의 길이가 줄어든다. 

!@chapter27/sparseArray.js@!

그보다 큰 값을 할당하면 변화가 없다. 자바스크립트는 배열의 요소가 일부가 비어있는 희소 배열을 허용한다. 

최적화 측면에서 희소 배열은 사용하지 않는 것이 좋다. 

### 4. 배열 생성

!@chapter27/arrayConstruct.js@!

### 6. 배열 요소의 추가와 갱신

현재 배열의 length 값보다 큰 인덱스로 요소(element)를 추가하면 희소 배열이 된다. 

0 이상의 정수를 사용하지 않으면 프로퍼티가 생성되고 lenght 값에 영향을 주지 않는다. 

### 7. 배열 요소의 삭제

delete로 프로퍼티를 삭제할 수 있지만 희소 배열이 되므로 추천하지 않는다. 

### 8. 배열 메서드

mutator method(원본 변경)와 accessor method(새로운 객체 반환)로 구분된다. 부수 효과 방지를 위해 후자가 권장된다. 

!@chapter27/arrayMethods.js@!

slice, 스프레드 문법, Object.assign 메서드는 모두 얕은 복사를 수행한다. 깊은 복사를 위해서는 [참고](https://lodash.com/docs/4.17.15#cloneDeep)

### 9. 배열 고차 함수

고차 함수(Highter-Order Function, HOF)

고차 함수는 외부 상태의 변경이나 가변(mutable) 데이터를 피하고 불변성(immutability)을 지향하는 함수형 프로그래밍에 기반을 두고 있다. 

> 함수형 프로그래밍은 순수 함수(pure function)와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다. 

!@chapter27/hof.js@!

> 최신 사양의 기능을 지원하지 않는 브라우저를 위해 누락된 최신 사양의 기능을 구현하여 추가하는 것을 폴리필(polyfill)이라 한다. 

## 28. Number

MAX_SAFE_INTEGER: 자바스크립트는 Number에서 부동소수점을 사용하기 때문. [참고](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)

## 31. RegExp

### 1. 정규 표현식이란?

> 정규표현식은(regular expression)은 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어(formal language)다. 

### 2. 정규 표현식의 생성

!@chapter31/regexConstruct.js@!

Regex 생성자 함수로 동적인 Regex 객체를 만들 수 있다. 

### 3. Regex 메서드

!@chapter31/regexMethod.js@!

### 4. 플래그

i: ignore case
g: global
m: multiline

### 5. 패턴

여기 이후는 저 자세히 설명되어있는 EloquentJavascript에서 다시 읽어보기. 

```text
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```

[이메일 regex...](https://emailregex.com)

## 32. String

### 1. String 생성자 함수

new 연산자를 사용하지 않고 String 생성자 함수를 호출하면 String 인스턴스가 아닌 문자열을 반환한다. 

### 2. length 프로퍼티

String은 length 프로퍼티를 갖기에 유사 배열 객체다. 

### 3. String 메서드

String 래퍼 객체도 읽기 전용 객체로 제공된다. 

!@chapter32/stringMethod.js@!

## 33. 7번째 데이터 타입 Symbol

### 2. 심벌 값의 생성

Symbol 함수는 new 연산자와 함께 호출하지 않는다. 심벌 값은 객체가 아닌 변경 불가능한 원시 값이다. 

!@chapter33/symbolMethod.js@!

### 3. 심벌과 상수

!@chapter33/symbolConstant.js@!

### 7. Well-known Symbol

> 자바스크립트가 기본 제공하는 빌트인 심벌 값을 ECMAScript 사양에서는 Well-known Symbol이라 부른다. 

Symbol.iterator 등등

이처럼 심벌은 중복되지 않는 상수 값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해, 즉 하위 호환성을 보장하기 위해 도입되었다. 

## 34. 이터러블

### 1. 이터레이션 프로토콜

> ES6에서 도입된 iteration protocol은 순회 가능한(iterable) 데이터 컬렉션(자료구조)을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다. 

이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있다. 

- 이터러블 프로토콜: 이터레이터를 반환. for...of, 스프레드 문법, 배열 디스트럭처링 할당. 
- 이터레이터 프로토콜: next 메서드 소유, iterator result object를 반환. 

스프레드 프로퍼티 제안은 일반 객체에 스프레드 문법의 사용을 허용한다. 

!@chapter34/iterable.js@!

### 3. for...of문

!@chapter34/forOf.js@!

### 4. 이터러블과 유사 배열 객체

유사 배열 객체는 for...of로 순회할 수 없다. Array.from으로 배열로 변환할 수 있다. 

!@chapter34/brokenIterable.js@!

### 6. 사용자 정의 이터러블

이터러블이면서 이터레이터인 객체를 생성하는 함수

!@chapter34/iterableNIterator.js@!

무한 이터러블을 생성하는 함수를 통해 무한 수열을 구현할 수 있다. 

> 지연 평가는 데이터가 필요한 시점 이전까지는 미리 데이터를 생성하지 않다가 필요한 시점이 되면 그때야 데이터를 생성하는 기법이다. 

무한 이터러블을 통해 지연 평가를 사용한 데이터 생성이 가능하다. 

## 35. 스프레드 문법

> ES6에서 도입된 스프레드 문법은 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. 

스프레드 문법의 결과는 값이 아니고, 따라서 ... 은 연산자가 아니다. 쉼표로 구분한 값의 목록을 사용하는 문백에서만 사용할 수 있다. 

Rest 파라미터와 스프레드 문법은 서로 반대의 개념이다. 

!@chapter35/restSpread.js@!

!@chapter35/rest.js@!

## 36. 디스트럭처링 할당

> 디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다. 

!@chapter36/destructuring.js@!
